/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as components from "../models/components";
import * as errors from "../models/errors";
import * as operations from "../models/operations";

export class Nango extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Returns a list of integrations including their unique keys and providers as configured in the Nango API.
     *
     * @remarks
     * Returns a list of integrations
     */
    async listIntegrations(options?: RequestOptions): Promise<operations.ListIntegrationsResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/config")();

        const query$ = "";

        const context = { operationID: "listIntegrations" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ListIntegrationsResponse$.inboundSchema.parse({
                ...responseFields$,
                IntegrationsResponse200: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Create a new integration including its provider configuration, OAuth details if applicable, and associated integration ID.
     *
     * @remarks
     * Create a new integration
     */
    async createIntegration(
        _input: components.ListIntegrationsRequest,
        options?: RequestOptions
    ): Promise<operations.CreateIntegrationsResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/config")();

        const query$ = "";

        const context = { operationID: "createIntegrations" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.CreateIntegrationsResponse$.inboundSchema.parse({
                ...responseFields$,
                IntegrationsResponse200: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Edit an integration, specifically tailored for OAuth APIs, updating the provider configuration along with OAuth client ID and secret.
     *
     * @remarks
     * Edit an integration (only for OAuth APIs)
     */
    async updateIntegration(
        _input: components.UpdateIntegrationRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateIntegrationResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/config")();

        const query$ = "";

        const context = { operationID: "updateIntegration" };
        const doOptions = { context, errorCodes: ["400", "404", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UpdateIntegrationResponse$.inboundSchema.parse({
                ...responseFields$,
                IntegrationsResponse200: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response404$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Returns details of a specific integration identified by its provider configuration key, optionally including credentials if specified.
     *
     * @remarks
     * Returns a specific integration
     */
    async getIntegration(
        providerConfigKey: string,
        includeCreds?: boolean | undefined,
        options?: RequestOptions
    ): Promise<operations.GetIntegrationResponse> {
        const input$: operations.GetIntegrationRequest = {
            providerConfigKey: providerConfigKey,
            includeCreds: includeCreds,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetIntegrationRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            providerConfigKey: enc$.encodeSimple("providerConfigKey", payload$.providerConfigKey, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/config/{providerConfigKey}")(pathParams$);

        const query$ = [
            enc$.encodeForm("include_creds", payload$.include_creds, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const context = { operationID: "getIntegration" };
        const doOptions = { context, errorCodes: ["400", "404", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetIntegrationResponse$.inboundSchema.parse({
                ...responseFields$,
                GetIntegrationResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response404$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Deletes a specific integration identified by its provider configuration key.
     *
     * @remarks
     * Deletes a specific integration
     */
    async deleteIntegration(
        providerConfigKey: string,
        options?: RequestOptions
    ): Promise<operations.DeleteIntegrationResponse> {
        const input$: operations.DeleteIntegrationRequest = {
            providerConfigKey: providerConfigKey,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.DeleteIntegrationRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            providerConfigKey: enc$.encodeSimple("providerConfigKey", payload$.providerConfigKey, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/config/{providerConfigKey}")(pathParams$);

        const query$ = "";

        const context = { operationID: "deleteIntegration" };
        const doOptions = { context, errorCodes: ["400", "404", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response404$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeleteIntegrationResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Returns a list of connections, optionally filtered by connection ID.
     *
     * @remarks
     * Returns a list of connections
     */
    async listConnections(
        connectionId?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.ListConnectionsResponse> {
        const input$: operations.ListConnectionsRequest = {
            connectionId: connectionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.ListConnectionsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/connection")();

        const query$ = [
            enc$.encodeForm("connectionId", payload$.connectionId, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const context = { operationID: "listConnections" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ListConnectionsResponse$.inboundSchema.parse({
                ...responseFields$,
                GetConnectionResponse: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Adds a connection using an existing access token, along with optional OAuth or basic authentication credentials, and additional metadata or configuration.
     *
     * @remarks
     * Adds a connection for which you already have an access token
     */
    async createConnections(
        _input: components.CreateConnectionRequest,
        options?: RequestOptions
    ): Promise<operations.CreateConnectionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/connection")();

        const query$ = "";

        const context = { operationID: "createConnection" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.CreateConnectionResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Returns details of a specific connection identified by its connection ID, associated with the specified integration, with optional parameters for force refresh and returning the refresh token.
     *
     * @remarks
     * Returns a specific connection
     */
    async getConnections(
        connectionId: string,
        providerConfigKey: string,
        forceRefresh?: boolean | undefined,
        refreshToken?: boolean | undefined,
        options?: RequestOptions
    ): Promise<operations.GetConnectionsResponse> {
        const input$: operations.GetConnectionsRequest = {
            connectionId: connectionId,
            providerConfigKey: providerConfigKey,
            forceRefresh: forceRefresh,
            refreshToken: refreshToken,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetConnectionsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            connectionId: enc$.encodeSimple("connectionId", payload$.connectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/connection/{connectionId}")(pathParams$);

        const query$ = [
            enc$.encodeForm("force_refresh", payload$.force_refresh, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("provider_config_key", payload$.provider_config_key, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("refresh_token", payload$.refresh_token, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const context = { operationID: "getConnections" };
        const doOptions = { context, errorCodes: ["400", "404", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response404$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.GetConnectionsResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Deletes a specific connection identified by its connection ID, associated with the specified integration.
     *
     * @remarks
     * Deletes a specific connection
     */
    async deleteConnections(
        connectionId: string,
        providerConfigKey: string,
        options?: RequestOptions
    ): Promise<operations.DeleteConnectionsResponse> {
        const input$: operations.DeleteConnectionsRequest = {
            connectionId: connectionId,
            providerConfigKey: providerConfigKey,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.DeleteConnectionsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            connectionId: enc$.encodeSimple("connectionId", payload$.connectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/connection/{connectionId}")(pathParams$);

        const query$ = [
            enc$.encodeForm("provider_config_key", payload$.provider_config_key, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const context = { operationID: "deleteConnections" };
        const doOptions = { context, errorCodes: ["400", "404", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response404$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeleteConnectionsResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Set custom metadata for the specified connection.
     *
     * @remarks
     * Set custom metadata for the connection.
     */
    async createMetadata(
        connectionId: string,
        providerConfigKey: string,
        requestBody: operations.CreateMetadataRequestBody,
        options?: RequestOptions
    ): Promise<operations.CreateMetadataResponse> {
        const input$: operations.CreateMetadataRequest = {
            connectionId: connectionId,
            providerConfigKey: providerConfigKey,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.CreateMetadataRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            connectionId: enc$.encodeSimple("connectionId", payload$.connectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/connection/{connectionId}/metadata")(pathParams$);

        const query$ = "";

        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "createMetadata" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 201)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.CreateMetadataResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Update custom metadata for the specified connection.
     *
     * @remarks
     * Update custom metadata for the connection.
     */
    async updateMetadata(
        connectionId: string,
        providerConfigKey: string,
        requestBody: operations.UpdateMetadataRequestBody,
        options?: RequestOptions
    ): Promise<operations.UpdateMetadataResponse> {
        const input$: operations.UpdateMetadataRequest = {
            connectionId: connectionId,
            providerConfigKey: providerConfigKey,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.UpdateMetadataRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            connectionId: enc$.encodeSimple("connectionId", payload$.connectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/connection/{connectionId}/metadata")(pathParams$);

        const query$ = "";

        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "updateMetadata" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UpdateMetadataResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Returns data synced with Nango Sync, filtered by specified parameters.
     *
     * @remarks
     * Returns data synced with Nango Sync
     */
    async getRecord(
        input: operations.GetRecordRequest,
        options?: RequestOptions
    ): Promise<operations.GetRecordResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetRecordRequest$.outboundSchema.parse(input);
        const body$ = null;

        const path$ = this.templateURLComponent("/records")();

        const query$ = [
            enc$.encodeForm("cursor", payload$.cursor, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("delta", payload$.delta, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("filter", payload$.filter, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("limit", payload$.limit, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("model", payload$.model, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "getRecord" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetRecordResponse$.inboundSchema.parse({
                ...responseFields$,
                GetRecordResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Returns data synced with Nango Sync, allowing for advanced filtering, sorting, and pagination options.
     *
     * @remarks
     * Returns data synced with Nango Sync
     */
    async getSyncRecord(
        input: operations.GetSyncRecordRequest,
        options?: RequestOptions
    ): Promise<operations.GetSyncRecordResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetSyncRecordRequest$.outboundSchema.parse(input);
        const body$ = null;

        const path$ = this.templateURLComponent("/sync/records")();

        const query$ = [
            enc$.encodeForm("delta", payload$.delta, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("filter", payload$.filter, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("limit", payload$.limit, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("model", payload$.model, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("offset", payload$.offset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("order", payload$.order, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_by", payload$.sort_by, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "getSyncRecord" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetSyncRecordResponse$.inboundSchema.parse({
                ...responseFields$,
                GetSyncRecordResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Triggers an additional, one-off execution of specified sync(s) for a given connection or all applicable connections if no connection is specified.
     *
     * @remarks
     * Triggers an additional, one-off execution of specified sync(s) (for a given connection or all applicable connections if no connection is specified).
     */
    async createSyncTrigger(
        input: components.CreateSyncTriggerRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateSyncTriggerResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = components.CreateSyncTriggerRequest$.outboundSchema
            .optional()
            .parse(input);
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/sync/trigger")();

        const query$ = "";

        const context = { operationID: "createSyncTrigger" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.CreateSyncTriggerResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Starts the continuous execution of specified sync(s) for a given connection or all applicable connections if no connection is specified.
     *
     * @remarks
     * Starts the continuous execution of specified sync(s) (for a given connection or all applicable connections if no connection is specified).
     */
    async createSyncStart(
        input: components.CreateSyncStartRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateSyncStartResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = components.CreateSyncStartRequest$.outboundSchema.optional().parse(input);
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/sync/start")();

        const query$ = "";

        const context = { operationID: "createSyncStart" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.CreateSyncStartResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Pauses the continuous execution of specified sync(s) for a given connection or all applicable connections if no connection is specified.
     *
     * @remarks
     * Pauses the continuous execution of specified sync(s) (for a given connection or all applicable connections if no connection is specified).
     */
    async createSyncPause(
        input: components.CreateSyncPauseRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateSyncPauseResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = components.CreateSyncPauseRequest$.outboundSchema.optional().parse(input);
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/sync/pause")();

        const query$ = "";

        const context = { operationID: "createSyncPause" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.CreateSyncPauseResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Get the status of specified sync(s) for a given connection or all applicable connections if no connection is specified.
     *
     * @remarks
     * Get the status of specified sync(s) (for a given connection or all applicable connections if no connection is specified)
     */
    async getSyncStatus(
        providerConfigKey: string,
        syncs: string,
        connectionId?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.GetSyncStatusResponse> {
        const input$: operations.GetSyncStatusRequest = {
            providerConfigKey: providerConfigKey,
            syncs: syncs,
            connectionId: connectionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetSyncStatusRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/sync/status")();

        const query$ = [
            enc$.encodeForm("connection_id", payload$.connection_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("provider_config_key", payload$.provider_config_key, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("syncs", payload$.syncs, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const context = { operationID: "getSyncStatus" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetSyncStatusResponse$.inboundSchema.parse({
                ...responseFields$,
                GetSyncStatusResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Override a sync's default frequency for a specific connection or revert to the default frequency.
     *
     * @remarks
     * Override a sync's default frequency for a specific connection, or revert to the default frequency.
     */
    async updateConnectionFrequency(
        input: components.UpdateConnectionFrequencyRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateConnectionFrequencyResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = components.UpdateConnectionFrequencyRequest$.outboundSchema.parse(input);
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/sync/update-connection-frequency")();

        const query$ = "";

        const context = { operationID: "updateConnectionFrequency" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UpdateConnectionFrequencyResponse$.inboundSchema.parse({
                ...responseFields$,
                UpdateConnectionFrequencyResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Triggers an action for a connection.
     *
     * @remarks
     * Triggers an action for a connection
     */
    async createActionTrigger(
        connectionId: string,
        providerConfigKey: string,
        createActionTriggerRequest: components.CreateActionTriggerRequest,
        options?: RequestOptions
    ): Promise<operations.CreateActionTriggerResponse> {
        const input$: operations.CreateActionTriggerRequest = {
            connectionId: connectionId,
            providerConfigKey: providerConfigKey,
            createActionTriggerRequest: createActionTriggerRequest,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.CreateActionTriggerRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.CreateActionTriggerRequest, {
            explode: true,
        });

        const path$ = this.templateURLComponent("/action/trigger")();

        const query$ = "";

        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "createActionTrigger" };
        const doOptions = { context, errorCodes: ["400", "4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.CreateActionTriggerResponse$.inboundSchema.parse({
                ...responseFields$,
                CreateActionTriggerResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.Response400$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Retrieve the environment variables as added in the Nango dashboard.
     *
     * @remarks
     * Retrieve the environment variables as added in the Nango dashboard
     */
    async getEnvironmentVariable(
        options?: RequestOptions
    ): Promise<operations.GetEnvironmentVariableResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/environment-variables")();

        const query$ = "";

        const context = { operationID: "getEnvironmentVariable" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetEnvironmentVariableResponse$.inboundSchema.parse({
                ...responseFields$,
                GetEnvironmentVariableResponse: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Make a GET request with the Proxy.
     *
     * @remarks
     * Make a GET request with the Proxy.
     */
    async getProxy(
        input: operations.GetProxyRequest,
        options?: RequestOptions
    ): Promise<operations.GetProxyResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.GetProxyRequest$.outboundSchema.parse(input);
        const body$ = null;

        const pathParams$ = {
            anyPath: enc$.encodeSimple("anyPath", payload$.anyPath, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/proxy/{anyPath}")(pathParams$);

        const query$ = [
            enc$.encodeForm("$ANY_QUERY_PARAMS", payload$.$ANY_QUERY_PARAMS, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        headers$.set(
            "Base-Url-Override",
            enc$.encodeSimple("Base-Url-Override", payload$["Base-Url-Override"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Decompress",
            enc$.encodeSimple("Decompress", payload$.Decompress, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Retries",
            enc$.encodeSimple("Retries", payload$.Retries, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "nango-proxy-$ANY_HEADER",
            enc$.encodeSimple("nango-proxy-$ANY_HEADER", payload$["nango-proxy-$ANY_HEADER"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "getProxy" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.GetProxyResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Make a POST request with the Proxy.
     *
     * @remarks
     * Make a POST request with the Proxy.
     */
    async createProxy(
        input: operations.CreateProxyRequest,
        options?: RequestOptions
    ): Promise<operations.CreateProxyResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = operations.CreateProxyRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$.CreateProxyRequest, { explode: true });

        const pathParams$ = {
            anyPath: enc$.encodeSimple("anyPath", payload$.anyPath, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/proxy/{anyPath}")(pathParams$);

        const query$ = "";

        headers$.set(
            "Base-Url-Override",
            enc$.encodeSimple("Base-Url-Override", payload$["Base-Url-Override"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Decompress",
            enc$.encodeSimple("Decompress", payload$.Decompress, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Retries",
            enc$.encodeSimple("Retries", payload$.Retries, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "nango-proxy-$ANY_HEADER",
            enc$.encodeSimple("nango-proxy-$ANY_HEADER", payload$["nango-proxy-$ANY_HEADER"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "createProxy" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.CreateProxyResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Make a PUT request with the Proxy.
     *
     * @remarks
     * Make a PUT request with the Proxy.
     */
    async putProxy(
        input: operations.PutProxyRequest,
        options?: RequestOptions
    ): Promise<operations.PutProxyResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = operations.PutProxyRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$.PutProxyRequest, { explode: true });

        const pathParams$ = {
            anyPath: enc$.encodeSimple("anyPath", payload$.anyPath, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/proxy/{anyPath}")(pathParams$);

        const query$ = "";

        headers$.set(
            "Base-Url-Override",
            enc$.encodeSimple("Base-Url-Override", payload$["Base-Url-Override"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Decompress",
            enc$.encodeSimple("Decompress", payload$.Decompress, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Retries",
            enc$.encodeSimple("Retries", payload$.Retries, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "nango-proxy-$ANY_HEADER",
            enc$.encodeSimple("nango-proxy-$ANY_HEADER", payload$["nango-proxy-$ANY_HEADER"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "putProxy" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.PutProxyResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Make a PATCH request with the Proxy.
     *
     * @remarks
     * Make a PATCH request with the Proxy.
     */
    async patchProxy(
        input: operations.PatchProxyRequest,
        options?: RequestOptions
    ): Promise<operations.PatchProxyResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = operations.PatchProxyRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$.PatchProxyRequest, { explode: true });

        const pathParams$ = {
            anyPath: enc$.encodeSimple("anyPath", payload$.anyPath, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/proxy/{anyPath}")(pathParams$);

        const query$ = "";

        headers$.set(
            "Base-Url-Override",
            enc$.encodeSimple("Base-Url-Override", payload$["Base-Url-Override"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Decompress",
            enc$.encodeSimple("Decompress", payload$.Decompress, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Retries",
            enc$.encodeSimple("Retries", payload$.Retries, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "nango-proxy-$ANY_HEADER",
            enc$.encodeSimple("nango-proxy-$ANY_HEADER", payload$["nango-proxy-$ANY_HEADER"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "patchProxy" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.PatchProxyResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Make a DELETE request with the Proxy.
     *
     * @remarks
     * Make a DELETE request with the Proxy.
     */
    async deleteProxy(
        input: operations.DeleteProxyRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteProxyResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DeleteProxyRequest$.outboundSchema.parse(input);
        const body$ = null;

        const pathParams$ = {
            anyPath: enc$.encodeSimple("anyPath", payload$.anyPath, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/proxy/{anyPath}")(pathParams$);

        const query$ = [
            enc$.encodeForm("$ANY_QUERY_PARAMS", payload$.$ANY_QUERY_PARAMS, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        headers$.set(
            "Base-Url-Override",
            enc$.encodeSimple("Base-Url-Override", payload$["Base-Url-Override"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Connection-Id",
            enc$.encodeSimple("Connection-Id", payload$["Connection-Id"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Decompress",
            enc$.encodeSimple("Decompress", payload$.Decompress, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Provider-Config-Key",
            enc$.encodeSimple("Provider-Config-Key", payload$["Provider-Config-Key"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "Retries",
            enc$.encodeSimple("Retries", payload$.Retries, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "nango-proxy-$ANY_HEADER",
            enc$.encodeSimple("nango-proxy-$ANY_HEADER", payload$["nango-proxy-$ANY_HEADER"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const context = { operationID: "deleteProxy" };
        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = await this.createRequest$(
            {
                context,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeleteProxyResponse$.inboundSchema.parse(responseFields$);
    }
}
